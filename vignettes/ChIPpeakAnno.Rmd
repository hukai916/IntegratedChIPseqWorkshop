---
title: "IntegratedChIPseqWorkshop"
vignette: >
  %\VignetteIndexEntry{integratedchipseqanalysisworkshop}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  html_document:
    css: custom.css
---

## Load required libraries
```{r "setup", include=FALSE}
suppressPackageStartupMessages({
  library(ChIPpeakAnno)
  library(biomaRt)
  library(AnnotationHub)
  library(EnsDb.Hsapiens.v75)
  library(TxDb.Hsapiens.UCSC.hg19.knownGene)
  library(BSgenome.Hsapiens.UCSC.hg19)
  library(org.Hs.eg.db)
  library(UpSetR)
  library(seqinr)
  library(motifStack)
})
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
i <- 0
generateFigureCaption <- function(cap){
    i <<- i+1
    return(paste0("Figure ", i, ". ", cap))
}
```

```{r eval=FALSE}
BiocManager::install("jianhong/workshop2020", build_vignettes = TRUE)
```


# Four steps for peak annotation

The functions, `toGRanges`, `annotatePeakInBatch`, and `addGeneIDs` in the
_ChIPpeakAnno_, make the annotation of ChIP-Seq peaks streamlined into 
four major steps:

1. Read peak data with `toGRanges`

2. Generate annotation data with `toGRanges`

3. Annotate peaks with `annotatePeakInBatch`

4. Add additional informations with `addGeneIDs`

```{r "quickStart"}
## First, load the ChIPpeakAnno package
library(ChIPpeakAnno)
```

## Step 1: convert the peak data from bed/broadPeak/narrowPeak etc. to `GRanges` with the `toGRanges` method

Here we use broadPeak file format as example.

```{r "import"}
## the sample file is included in ChIPpeakAnno package. 
## chage the file path into your own file path to handle your data
path <- system.file("extdata", "Tead4.broadPeak", package="ChIPpeakAnno")
## toGRanges is overlaoded method,
## by define the correct file format to import the file in correct coordinates
peaks <- toGRanges(path, format="broadPeak")
## see top 2 lines of the imported peaks.
## the imported peaks will be packaged into GRanges object
head(peaks, n=2)
```


## Step 2: prepare annotation data with the `toGRanges` method

ChIP-seq is a kind of DNA-seq. In the mapping step, no transcriptome is used.
In the annotation step, both Ensembl or UCSC annotations can be used. 
Depend on your research, less complex genome annotations, 
such as UCSC annotations, are prefearable for reproducible and robust 
gene/transcripts annotation. To discover and explain unknown biological
mechanisms, more comprehensive and complex genome annotations are necessary,
such as Ensembl.

Here we show how to prepare annotations based on **TxDb** package with the 
`toGRanges` method.

```{r "TxDbAnnoData"}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
annoDataTxDb <- toGRanges(TxDb.Hsapiens.UCSC.hg19.knownGene)
head(annoDataTxDb, n=2)
```

We can also prepare annotations based on **EnsDb** package with the `toGRanges`
method.

```{r "EndDbAnnoData"}
library(EnsDb.Hsapiens.v75) ##GRCh37.p13
annoDataEnsDb <- toGRanges(EnsDb.Hsapiens.v75)
head(annoDataEnsDb, n=2)
```
The shortage of offline annotation packages is that it may not contain 
up-to-date data. We can also use online annotation data via the _biomaRt_ or
_AnnotationHub_ packages. However, to use the _biomaRt_ package, you must be 
very clear that the default mart service is based the newrest genome assembly.
For example, if you are annotating the data mapped to hg19/GRCh37 or mm9/NCBIM37
assembly, you must change the default server into achive server. For more
details, please refer the documentation of the _biomaRt_ package.

```{r "biomaRtAnnoData", eval=FALSE}
library(biomaRt)
## here we use ensembl GRCh37.p13 (V75) service, 
## use listEnsemblArchives() function to list the available host
## use listDatasets() function to list the available dataset
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl",
                host = "feb2014.archive.ensembl.org")
## use the getAnnotation function to obtain the TSS for ensembl GRCh37.p13.
annoDataMart <- getAnnotation(mart, featureType = "TSS")
annoDataMart[head(names(annoDataEnsDb), n=2)]
```
```{r "biomaRtAnnoDataFake", include=FALSE}
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl",
                host = "feb2014.archive.ensembl.org")
annoDataMart <- readRDS(system.file("extdata", "ChIPpeakAnno", "annoDataMart.rds",
                                    package = "integratedchipseqanalysisworkshop", mustWork = TRUE))
annoDataMart[head(names(annoDataEnsDb), n=2)]
```

Here I show some sample code to get annotations from AnnotationHub.

```{r "annoHubAnnoData"}
library(AnnotationHub)
ah <- AnnotationHub()
hg19 <- AnnotationHub::query(ah, c("UCSC", "Hsapiens", "hg19", "knownGene"))
hg19
hg19TxDb <- hg19[["AH52258"]]
annoDataHg19<- toGRanges(hg19TxDb)
identical(annoDataHg19, annoDataTxDb)
## retrieve the gencode v32 annotation
GRCh37 <- AnnotationHub::query(ah, c("GRCh37", "GENCODE", "v32", "TxDb"))
annoDataGencode <- toGRanges(GRCh37[["AH75188"]])
head(annoDataGencode, n=2)
```


## Step 3: annotate the peaks with the `annotatePeakInBatch` function.

Here we will compare the difference among differnt annotation sources.

First we compare the annotations from ensembl GRCh37.p13 between the
_EnsDb.Hsapiens.v75_ package and ensembl archives.

```{r "annotateEnsDb", fig.cap=generateFigureCaption("Pie chart of common peaks among EnsDb features.")}
seqlevelsStyle(annoDataEnsDb)
seqlevelsStyle(peaks)
## keep the seqnames in the same style
if(!identical(seqlevelsStyle(peaks), seqlevelsStyle(annoDataEnsDb))){
  seqlevelsStyle(peaks) <- seqlevelsStyle(annoDataEnsDb)[1]
}
## do annotation by nearest TSS of Ensembl GRCh37.p13
annoEnsDb <- annotatePeakInBatch(peaks, AnnotationData=annoDataEnsDb)
head(annoEnsDb, n=2)
# A pie chart can be used to demonstrate the overlap features of the peaks.
pie1(table(annoEnsDb$insideFeature))
```

```{r "annotateBiomaRt", fig.cap=generateFigureCaption("Pie chart of common peaks among biomart features.")}
## keep the seqnames in the same style
if(!identical(seqlevelsStyle(peaks), seqlevelsStyle(annoDataMart))){
  seqlevelsStyle(peaks) <- seqlevelsStyle(annoDataMart)[1]
}
## do annotation by nearest TSS of Ensembl GRCh37.p13
annoMart <- annotatePeakInBatch(peaks, AnnotationData=annoDataMart)
head(annoMart, n=2)
# A pie chart can be used to demonstrate the overlap features of the peaks.
pie1(table(annoMart$insideFeature))
```

We can see the minor difference between them. Lets check the reasons.

```{r "diffBiomaRtEnsDb"}
## check how many annotations are different from each other
table(start(annoDataMart[names(annoDataEnsDb)])==start(annoDataEnsDb))
table(end(annoDataMart[names(annoDataEnsDb)])==end(annoDataEnsDb))
## get the samples
head(annoDataMart[names(annoDataEnsDb)][
  start(annoDataMart[names(annoDataEnsDb)])!=start(annoDataEnsDb)], n=2)
head(annoDataEnsDb[start(annoDataMart[names(annoDataEnsDb)])!=
                     start(annoDataEnsDb)], n=2)
## check the biomart output
getBM(attributes = c("ensembl_gene_id", 'chromosome_name', "description"),
      filters = "ensembl_gene_id", values = c("LRG_198", "LRG_262"), 
      mart = mart)
```
Here we can see that the _EnsDb.Hsapiens.v75_ package already fixed the issue
of chromosome_name issue, where the biomart online still output the wrong 
chromosome_name. 

Now we annotate the peaks by UCSC hg19 annotations.

```{r annotateTxDb, fig.cap=generateFigureCaption("Pie chart of common peaks among TxDb features.")}
## keep the seqnames in the same style
if(!identical(seqlevelsStyle(peaks), seqlevelsStyle(annoDataTxDb))){
  seqlevelsStyle(peaks) <- seqlevelsStyle(annoDataTxDb)[1]
}
## do annotation by nearest TSS of UCSC hg19 annotations
annoTxDb <- annotatePeakInBatch(peaks, AnnotationData=annoDataTxDb)
head(annoTxDb, n=2)
# A pie chart can be used to demonstrate the overlap features of the peaks.
pie1(table(annoTxDb$insideFeature))
```
Now we try to use gencode v32 annotations to annotate the peaks.

```{r annotateGencode, fig.cap=generateFigureCaption("Pie chart of common peaks among Gencode features.")}
## keep the seqnames in the same style
if(!identical(seqlevelsStyle(peaks), seqlevelsStyle(annoDataGencode))){
  seqlevelsStyle(peaks) <- seqlevelsStyle(annoDataGencode)[1]
}
## do annotation by nearest TSS of Gencode
annoGencode <- annotatePeakInBatch(peaks, AnnotationData=annoDataGencode)
head(annoGencode, n=2)
# A pie chart can be used to demonstrate the overlap features of the peaks.
pie1(table(annoGencode$insideFeature))
```


We can see the difference between the annotations among Ensembl, 
UCSC and Gencode in annotation. Let's check the overlaps of annotations.

```{r "Ensembl.vs.UCSC", fig.cap=generateFigureCaption("The overlap and intersection among UCSC, Ensembl, and Gencode annotations.")}
Ensembl <- unique(annoDataEnsDb)
UCSC <- unique(annoDataTxDb)
Gencode <- unique(annoDataGencode)
## make the sequence info to same, otherwise can not compare.
genome(seqinfo(Gencode)) <- 
  genome(seqinfo(UCSC)) <- 
  genome(seqinfo(Ensembl)) <- factor("hg19")
isCircular(seqinfo(UCSC)) <- rep(FALSE, length(seqlevels(UCSC)))
isCircular(seqinfo(Gencode)) <- rep(FALSE, length(seqlevels(Gencode)))
seqlengths(Ensembl)["chrM"] <- seqlengths(UCSC)["chrM"]
## find the overlaps by max gap = 0 bp.
ol <- findOverlapsOfPeaks(Ensembl, 
                          UCSC, 
                          Gencode,
                          ignore.strand = FALSE,
                          connectedPeaks="keepAll")
## venn diagram to show the overlaps
makeVennDiagram(ol, connectedPeaks = "keepAll")
```


## Step 4: add additional annotation with the `addGeneIDs` function
```{r "addIDs", fig.cap=generateFigureCaption("upset plot of common gene symbols among annotations by Ensembl, UCSC and Gencode features.")}
library(org.Hs.eg.db)
annoEnsDb <- addGeneIDs(annoEnsDb, orgAnn="org.Hs.eg.db", 
                        feature_id_type="ensembl_gene_id",
                        IDs2Add=c("symbol"))
head(annoEnsDb, n=2)
annoTxDb <- addGeneIDs(annoTxDb, orgAnn="org.Hs.eg.db", 
                        feature_id_type="entrez_id",
                        IDs2Add=c("symbol"))
head(annoTxDb, n=2)
annoGencode$entrez_id <- xget(sub("(ENSG\\d{11}).*$", "\\1", 
                                  as.character(annoGencode$feature)), 
                              org.Hs.egENSEMBL2EG, 
                              output = "last")
annoGencode$symbol[!is.na(annoGencode$entrez_id)] <- 
  xget(annoGencode$entrez_id[!is.na(annoGencode$entrez_id)], org.Hs.egSYMBOL)
head(annoGencode)
library(UpSetR)
upset(fromList(list(Ensembl=unique(annoEnsDb$symbol),
                    UCSC=unique(annoTxDb$symbol),
                    Gencode=unique(annoGencode$symbol))),
      order.by = "freq")
```

As a conclusion, annotate with different annotation resources, even the other
parameter keep same, the annotations will be different from each other.
To improve the reproducibility, accuracy of an annotation source should be 
provided. Some people were advertizing their tools by playing this trick 
by using different annotations to mislead users. 


# Find overlaps for replicates

The function `findOverlapsOfPeaks` returns an object of **overlappingPeaks**, 
which contains there elements: venn_cnt, peaklist (a list of  
overlapping peaks or unique peaks), and overlappingPeaks (a list of data frame 
consists of the annotation of all the overlapping peaks). 

The following examples illustrate the usage of this method to convert BED and 
GFF file to GRanges, add metadata from orignal peaks to the overlap GRanges 
using function `addMetadata`, and visualize the overlapping using function
`makeVennDiagram`.

```{r "findOverlapsOfPeaks", fig.cap=generateFigureCaption("Venn diagram of overlaps for replicated experiments"), fig.width=6, fig.height=6}
library(ChIPpeakAnno)
bed <- system.file("extdata", "MACS_output.bed", package="ChIPpeakAnno")
gr1 <- toGRanges(bed, format="BED", header=FALSE) 
## one can also try import from rtracklayer
gff <- system.file("extdata", "GFF_peaks.gff", package="ChIPpeakAnno")
gr2 <- toGRanges(gff, format="GFF", header=FALSE, skip=3)
## must keep the class exactly same as gr1$score, i.e., numeric.
gr2$score <- as.numeric(gr2$score) 
ol <- findOverlapsOfPeaks(gr1, gr2, connectedPeaks = "keepAll")
## add metadata (mean of score) to the overlapping peaks
ol <- addMetadata(ol, colNames="score", FUN=mean) 
head(ol$peaklist[["gr1///gr2"]], n=2)
makeVennDiagram(ol, fill=c("#009E73", "#F0E442"), # circle fill color
                col=c("#D55E00", "#0072B2"), #circle border color
                cat.col=c("#D55E00", "#0072B2")) # label color, keep same as circle border color
```

But if we check the sum of the overlaps, the total number for each sample are 
not identical to inputed peak number. This can be fixed by set 'connectedPeaks'
parameter into 'keepAll'.

```{r "vennDiagramKeepAll", fig.cap=generateFigureCaption("Venn diagram of overlaps with all original counts."), fig.width=6, fig.height=6}
length(gr1)
length(gr2)
62+166
61+166
makeVennDiagram(ol, fill=c("#009E73", "#F0E442"),
                col=c("#D55E00", "#0072B2"),
                cat.col=c("#D55E00", "#0072B2"),
                connectedPeaks = "keepAll")
```



# Select annotation method

## Visualize binding site distribution relative to features

The `assignChromosomeRegion` function can be used to summarize the distribution 
of  peaks over different type of features such as exon, intron, enhancer, 
proximal promoter, 5' UTR and 3' UTR. 
This distribution can be summarized in peak centric or nucleotide centric view
using the function `assignChromosomeRegion`. 
Please note that one peak might span multiple type of features, leading to the 
number of annotated features greater than the total number of input peaks. 
At the peak centric view, precedence will dictate the annotation order when 
peaks span multiple type of features.

The sample code here plots the distribution of peaks are enriched around the 
promoters.

```{r "assignChromosomeRegion",fig.cap=generateFigureCaption("Peak distribution over different genomic features."),fig.width=10,fig.height=4}
overlaps <- ol$peaklist[["gr1///gr2"]] ## get the overlapping peaks
## load TxDb to assign genomic elements
library(TxDb.Hsapiens.UCSC.hg19.knownGene) 
aCR<-assignChromosomeRegion(overlaps, nucleotideLevel=FALSE, 
                           precedence=c("Promoters", "immediateDownstream", 
                                         "fiveUTRs", "threeUTRs", 
                                         "Exons", "Introns"), 
                           TxDb=TxDb.Hsapiens.UCSC.hg19.knownGene)
barplot(aCR$percentage, las=3)
```

In addition, the distribution of the distance of overlapped peaks to the nearest
feature such as the transcription start sites (TSS) can be plotted by the 
`binOverFeature` function. 
The sample code here plots the distribution of peaks around the TSS.

```{r "binOverFeature",fig.cap=generateFigureCaption("Distribution of peaks around transcript start sites."),fig.width=8,fig.height=6}
binOverFeature(overlaps, annotationData=annoDataTxDb,
               radius=5000, nbins=20, FUN=length, errFun=0,
               ylab="count", 
               main="Distribution of aggregated peak numbers around TSS")
```


## Annotate peaks

The `annotatePeakInBatch` function provide multiple methods to annotate the 
peaks and those methods can be set by combination of multiple parameters.
The 'output' is the key parameter to determine the annotation method.
The default method is search the nearest features calculated as 
'PeakLoc - FeatureLocForDistance'. For more information, please refer the
documentation of the `annotatePeakInBatch` function.

As shown from the distribution of aggregated peak numbers around TSS and 
the distribution of peaks in different of chromosome regions,
most of the peaks locate around TSS. Therefore, it is reasonable to use 
the `annotatePeakInBatch` or `annoPeaks` 
to annotate the peaks to the promoter regions of Hg19/GRCh37 genes. 
Promoters can be specified with 'bindingRegion'. 
For the following example, promoter region is defined as upstream 2000 and 
downstream 500 from TSS (bindingRegion=c(-2000, 500)).

```{r workflow3}
overlaps.anno <- annotatePeakInBatch(overlaps, 
                                     AnnotationData=annoDataTxDb, 
                                     output="nearestBiDirectionalPromoters",
                                     bindingRegion=c(-2000, 500))
library(org.Hs.eg.db)
overlaps.anno <- addGeneIDs(overlaps.anno,
                            "org.Hs.eg.db",
                            feature_id_type="entrez_id",
                            IDs2Add = "symbol")
head(overlaps.anno, n=2)
library(WriteXLS)
WriteXLS(as.data.frame(unname(overlaps.anno)), "anno.xls")
```

The distribution of the common peaks around features can be visualized using 
a pie chart.

```{r "pieChartBiPromoter",fig.cap=generateFigureCaption("Pie chart of the distribution of common peaks around features.")}
pie1(table(overlaps.anno$insideFeature))
```


# Obtain enriched GO terms and Pathways

The following example shows how to use `getEnrichedGO` to obtain a list of 
enriched GO terms with annotated peaks. 
For pathway analysis, please use function `getEnrichedPATH` with reactome or 
KEGG database. Please note that by default  _feature\_id\_type_ is set as 
"ensembl\_gene\_id". 
If you are using **TxDb** as annotation data, please set it to "entrez\_id".
```{r enrichment}
over <- getEnrichedGO(overlaps.anno, orgAnn="org.Hs.eg.db", 
                      feature_id_type="entrez_id",
                      maxP=.05, minGOterm=10, 
                      multiAdjMethod="BH", condense=TRUE)
head(over[["bp"]][, -c(3, 10)], n=2)
library(reactome.db)
path <- getEnrichedPATH(overlaps.anno, "org.Hs.eg.db", "reactome.db", 
                        feature_id_type="entrez_id", maxP=.05)
head(path, n=2)
```

# Output a summary of consensus in the peaks

There are multiple methods to get the consensus in the peaks:

1. output the fastq file by the `getAllPeakSequence` function  and
search the motif by the 3rd program such as homer, MEME, and so on.

2. test the pre-defined consensus patterns to see if target consensus are 
enriched or not by the `summarizePatternInPeaks` function.

3. calculate the z-scores of all combinations of oligonucleotide in a given
length by Markove chain by the `oligoSummary` function.

Here is an example to get the Z-scores for short oligos.

```{r "consensus",fig.cap=generateFigureCaption("Histogram of Z-score of 6-mer"),fig.height=6,fig.width=6}
library(seqinr)
library(BSgenome.Hsapiens.UCSC.hg19)
seq <- getAllPeakSequence(overlaps, 
                          upstream=20, downstream=20, 
                          genome=Hsapiens)
## output the fasta file for the 3nd program
write2FASTA(seq, "test.fa")
## summary of the short oligos
os <- oligoSummary(seq, oligoLength=6, MarkovOrder=3, 
                   quickMotif=TRUE)
## plot the results
zscore <- sort(os$zscore)
h <- hist(zscore, breaks=100, main="Histogram of Z-score")
text(zscore[length(zscore)], max(h$counts)/10, 
     labels=names(zscore[length(zscore)]), srt=90)
```
```{r "simulation.motif", fig.cap=generateFigureCaption("Motif of simulation data"), fig.width=6, fig.height=6}
## generate the motifs
library(motifStack)
pfms <- mapply(function(.ele, id)
    new("pfm", mat=.ele, name=paste("SAMPLE motif", id)), 
    os$motifs, 1:length(os$motifs))
motifStack(pfms)
```

# Find peaks with bi-directional promoters

Bidirectional promoters are the DNA regions located between TSS 
of two adjacent genes that are transcribed on opposite directions 
and often co-regulated by this shared promoter region. 
Here is an example to find peaks near bi-directional promoters.

```{r peaksNearBDP16}
bdp <- peaksNearBDP(overlaps, annoDataTxDb, maxgap=5000)
c(bdp$percentPeaksWithBDP, 
  bdp$n.peaks, 
  bdp$n.peaksWithBDP)
head(bdp$peaksWithBDP, n=2)
```


# Determine if there is a significant overlap among multiple sets of peaks

Given two or more peak lists from different TFs, one may be interested in finding 
whether DNA binding profile of those TFs are correlated, and if correlated, 
what is the common binding pattern.

Here we will show how to compare binding profiles from multiple transcription
factors (TFs) by ChIP-seq sample data of TAF, YY1 and Tead4 from mouse.

```{r "importData"}
path <- system.file("extdata", package="ChIPpeakAnno")
files <- dir(path, "broadPeak")
data <- sapply(file.path(path, files), toGRanges, format="broadPeak")
(names(data) <- gsub(".broadPeak", "", files))
```

## Hypergeometric test

When we test the association between two sets of data based on hypergeometric 
distribution, the number of all potential binding sites is required. 
The parameter _totalTest_ in the `makeVennDiagram` function indicates how many 
potential peaks in total will be used in the hypergeometric test. It should be 
larger than the largest number of peaks in the peak list. The smaller it is 
set, the more stringent the test is. The time used to calculate p-value does not
depend on the value of the _totalTest_. 
For practical guidance on how to choose _totalTest_, 
please refer to the [post](https://stat.ethz.ch/pipermail/bioconductor/2010-November/036540.html).
The following example makes an assumption that there are 3% of coding region 
plus promoter region. Because the sample data is only a subset of chromosome 2, 
we estimate that the total binding sites is 1/24 of possible binding region 
in the genome.

```{r "vennDiagram", fig.cap=generateFigureCaption("Venn diagram of overlaps."), fig.width=6, fig.height=6}
ol <- findOverlapsOfPeaks(data, connectedPeaks="keepAll")
averagePeakWidth <- mean(width(unlist(GRangesList(ol$peaklist))))
tot <- ceiling(3.3e+9 * .03 / averagePeakWidth / 24)
makeVennDiagram(ol, totalTest=tot, connectedPeaks="keepAll", 
                fill=c("#CC79A7", "#56B4E9", "#F0E442"), # circle fill color
                col=c("#D55E00", "#0072B2", "#E69F00"), #circle border color
                cat.col=c("#D55E00", "#0072B2", "#E69F00"))
```
```{r "vennDiagramForFirstConsistent", fig.cap=generateFigureCaption("Venn diagram of overlaps for first TF."), fig.width=6, fig.height=6}
## see the difference if we set connectedPeaks to "keepFirstListConsistent"
## set connectedPeaks to keepFirstListConsistent will show consistent total 
## number of peaks for the first peak list.
makeVennDiagram(ol, totalTest=tot, connectedPeaks="keepFirstListConsistent", 
                fill=c("#CC79A7", "#56B4E9", "#F0E442"),
                col=c("#D55E00", "#0072B2", "#E69F00"),
                cat.col=c("#D55E00", "#0072B2", "#E69F00"))

```

## Permutation test

The above hypergeometric test requires users to input an estimate of 
the total potential binding sites for a given TF. 
To circumvent this requirement, we implemented a permutation test called 
`peakPermTest`. 
Before performing a permutation test, users need to generate random peaks 
using the distribution discovered from the input peaks for a given feature type 
(transcripts or exons), to make sure the binding positions relative to features, 
such as TSS and geneEnd, and the width of the random peaks follow the
distribution of that of the input peaks.

Alternatively, a peak pool representing all potential 
binding sites can be created with associated binding probabilities for 
random peak sampling using the `preparePool` function. 
Here is an example to build a peak pool for human genome using the 
transcription factor binding site clusters (V3) (see ?`wgEncodeTfbsV3`) 
downloaded from [ENCODE](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeRegTfbsClustered/wgEncodeRegTfbsClusteredV3.bed.gz) 
with the HOT spots (?`HOT.spots`) removed. 
HOT spots are the genomic regions with high probability of being bound by many 
TFs in ChIP-seq experiments. 
We suggest remove those HOT spots from the peak lists before performing 
permutation test to avoid the overestimation of the association between the 
two input peak lists. 
Users can also choose to remove [ENCODE blacklist](https://sites.google.com/site/anshulkundaje/projects/blacklists) for a given species.
The blacklists were constructed by identifying consistently problematic regions
over independent cell lines and types of experiments for each species in the 
ENCODE and modENCODE datasets. 
Please note that some of the blacklists may need to be converted to the correct 
genome assembly using liftover utility.

Following are the sample codes to do the permutation test using the `permTest` 
function:

```{r "peakPermTest1", fig.cap=generateFigureCaption("permutation test for YY1 and TEAD4")}
    data(HOT.spots)
    data(wgEncodeTfbsV3)
    hotGR <- reduce(unlist(HOT.spots))
    removeOl <- function(.ele){
        ol <- findOverlaps(.ele, hotGR)
        if(length(ol)>0) .ele <- .ele[-unique(queryHits(ol))]
        .ele
    }
    TAF <- removeOl(data[["TAF"]])
    TEAD4 <- removeOl(data[["Tead4"]])
    YY1 <- removeOl(data[["YY1"]])
    # we subset the pool to save demo time
    set.seed(1)
    wgEncodeTfbsV3.subset <- 
        wgEncodeTfbsV3[sample.int(length(wgEncodeTfbsV3), 2000)]
    pool <- new("permPool", grs=GRangesList(wgEncodeTfbsV3.subset), N=length(YY1))
    pt1 <- peakPermTest(YY1, TEAD4, pool=pool, seed=1, force.parallel=FALSE)
    plot(pt1)
```
```{r peakPermTest2, fig.cap=generateFigureCaption("permutation test for YY1 and TAF")}
    pt2 <- peakPermTest(YY1, TAF, pool=pool, seed=1, force.parallel=FALSE)
    plot(pt2)
```


# Metagene analysis for given feature/peak ranges

You can easily visualize and compare the binding patterns of raw signals of 
multiple ChIP-Seq experiments using function 
`featureAlignedHeatmap` and `featureAlignedDistribution`.

```{r "heatmap",fig.cap=generateFigureCaption("Heatmap of aligned features sorted by signal of TAF"),fig.width=4,fig.height=6}
features <- ol$peaklist[[length(ol$peaklist)]]
feature.recentered <- reCenterPeaks(features, width=4000)
## here we also suggest importData function in bioconductor trackViewer package 
## to import the coverage.
## compare rtracklayer, it will save you time when handle huge dataset.
library(rtracklayer)
files <- dir(path, "bigWig")
if(.Platform$OS.type != "windows"){
    cvglists <- sapply(file.path(path, files), import, 
                       format="BigWig", 
                       which=feature.recentered, 
                       as="RleList")
}else{## rtracklayer can not import bigWig files on Windows
    load(file.path(path, "cvglist.rds"))
}
names(cvglists) <- gsub(".bigWig", "", files)
feature.center <- reCenterPeaks(features, width=1)
sig <- featureAlignedSignal(cvglists, feature.center, 
                            upstream=2000, downstream=2000)
##Because the bw file is only a subset of the original file,
##the signals are not exists for every peak.
keep <- rowSums(sig[[2]]) > 0
sig <- sapply(sig, function(.ele) .ele[keep, ], simplify = FALSE)
feature.center <- feature.center[keep]
heatmap <- featureAlignedHeatmap(sig, feature.center, 
                                 upstream=2000, downstream=2000,
                                 upper.extreme=c(3,.5,4))
```

```{r "distribution",fig.cap=generateFigureCaption("Distribution of aligned features"),fig.width=6,fig.height=6}
featureAlignedDistribution(sig, feature.center, 
                           upstream=2000, downstream=2000,
                           type="l")
```


# Below is for trackViewer:

```{r checkplatform, include=FALSE}
library(knitr)
suppressPackageStartupMessages({
  library(trackViewer)
  library(pander)
  library(VariantAnnotation)
  library(TxDb.Hsapiens.UCSC.hg19.knownGene)
  library(org.Hs.eg.db)
  library(GenomicFeatures)
  library(org.Mm.eg.db)
})
opts_chunk$set(eval=TRUE, fig.width=6, fig.height=2, 
               warning = FALSE, message = FALSE)
```

## Introduction

It is a routine way to show the distribution of mutation for genetic variations by lollipop-style (or needle-style) plot in a genome browser, along with a variety of genomic annotations, such as gene level or exon level models, CpG island, and so on. To show the SNP status or methylation data, a special plot, called lollipop plot or needle plot, is used to show the distribution along annotations. Many of currently available tools offline or online provide lollipop-like plot to show the mutation data such as cBioPortal Tools::MutationMapper[@gao2013integrative], EMBL-EBI::Pfam[@finn2006pfam], and BioJS::muts-needle-plot[@michael_p_schroeder_2015_14561], BiQ Analyzer[@bock2005biq], and Methylation plotter[@mallona2014methylation]. The cBioPortal Tools::MutationMapper is a well-known and easy to use on-line genome browser that can output high quality of figures with mutations by input tab-delimited mutation data. In R/Bioconductor, there are options to use the flexibility of the Rgraphics system to display Methylation data such as _MethVisual_[@zackay2010methvisual], _REDseq_[@zhu4redseq], and _GenVisR_[@skidmore2016genvisr]. 

**Table 1: Tools availble for lollipop plot. **
```{r echo=FALSE}
software <- c("MutationMapper[@gao2013integrative]", "Pfam[@finn2006pfam]", "muts-needle-plot[@michael_p_schroeder_2015_14561]", "BiQ Analyzer[@bock2005biq]", "Methylation plotter[@mallona2014methylation]", "_MethVisual_[@zackay2010methvisual]", "_REDseq_[@zhu4redseq]", "_GenVisR_[@skidmore2016genvisr]")
inputs <- c("tab-delimited text", "JSON", "JSON", "BiQ methylation file", "tab-delimited text", "R list", "R list", "R dataframe")
online <- c("Yes", "Yes", "No", "Yes", "Yes", "No", "No", "No")
description <- c("interprets mutations with different heights along protein annotations in automatic color theme", "could combine different line and head colors with different drawing styles", "plots data point with different colors, heights, and size along annotations, and highlighted selcted coordinates", "interprets methylation status in black & white", "stacked multiple methylation status for multiple samples", "visualize the methylation status of CpGs according to their genomic position", "plot frequencies of methylations and SNPs along a chromosome", "plot most accurate graphic representation of the ensembl annotation version based on biomart service")
df <- data.frame(software=software, inputs=inputs, online=online, description=description)

library(pander)
panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('keep.trailing.zeros', TRUE)
pander(df)
```


All the tools available for the genomic data visualization mentioned above can meet the basic even complicated requirement. However, if there are multiple mutations in almost same position, it is very difficult to display the data using any available tools. What's more there is a tendency that the figures it generated become more and more complex and busy. Thereby make it difficult in generating high quality pictures for publication in bunch. To fill this gap, we developed _trackViewer_, a R/Bioconductor package as an enhanced light-weight genome viewer for visualizing various types of high-throughput sequencing data, side by side or stacked with multiple annotation tracks. Besides the regular read coverage tracks supported by existing genome browsers/viewers,  _trackViewer_ can also be used to generate lollipop plot to depict the methylation and SNP/mutation status, together with coverage data and annotation tracks to facilitate integrated analysis of multi-omics data. In addition, figures generated by _trackViewer_ are interactive, i.e., the feel-and-look such as the layout, the color scheme and the order of tracks can be easily customized by the users. Furthermore, _trackViewer_ can be easily integrated into standard analysis pipeline for various high-throughput sequencing dataset such as ChIP-seq, RNA-seq, methylation-seq or DNA-seq. The images produced by _trackViewer_ are highly customizable including labels, symbols, colors and size. Here, we illustrate its utilities and capabilities in deriving biological insights from multi-omics dataset from GEO/Encode.


## Installation

_BiocManager_ is used to install the released version of _trackViewer_.

```{r eval=FALSE}
library(BiocManager)
install("trackViewer")
```

To install the development version of _trackViewer_, please try

```{r eval=FALSE}
library(BiocManager)
install("jianhong/trackViewer")
```

To check the current version of _trackViewer_, please try

```{r}
packageVersion("trackViewer")
```

## Quick start for lollipop plot

### Step 1. Prepare the methylation/variant/mutation data

The input data for lollipop plot by _trackViewer_ is an object of _GenomicRanges_::`GRanges`.

```{r quickStartStep1}
## load library
library(trackViewer)
set.seed(123) ## set seed for random sampling to make sure it can be repeat.
## Here we use SNP sample data
SNP <- c(10, 100, 105, 108, 400, 410, 420, 600, 700, 805, 840, 1400, 1402)
## use GenomicRanges::GRanges function to create a GRanges object.
## for real data, users can import vcf data via VariantAnnotation::readVcf function.
sample.gr <- GRanges("chr1", IRanges(SNP, width=1, 
                                     ## the name of GRanges object will be used as label
                                     names=paste0("snp", SNP)),
                     ## score value will be used to for the height of lollipop
                     score = sample.int(5, length(SNP), replace = TRUE),
                     ## set the color for lollipop node.
                     color = sample.int(6, length(SNP), replace = TRUE),
                     ## set the lollipop stem color
                     border = sample(c("black", "gray80", "gray30"),
                                     length(SNP), replace=TRUE)
                     )
```

### Step 2. Prepare the gene/protein model

The gene/protein model for lollipop plot by _trackViewer_ is also an object of _GenomicRanges_::`GRanges`.

```{r quickStartStep2}
features.gr <- GRanges("chr1", IRanges(c(1, 501, 1001), 
                                       width=c(120, 400, 405),
                                       names=paste0("exon", 1:3)),
                       fill = c("#FF8833", "#51C6E6", "#DFA32D"), ## color for exon
                       height = c(0.02, 0.05, 0.08) ## height for exon
                    )
```

### Step 3. Plot lollipop plot

The clustered events could be visualized one by one by jittered lollipop positions.

```{r quickStartStep3, fig.width=6, fig.height=3.5}
lolliplot(sample.gr, features.gr)
```


## Plot data from Variant Call Format (VCF) file

VCF is a text file format that contains metadata and mutation information about
genomic positions, original genotypes and optional genotypes. 
The _trackViewer_ package could show single nucleotide polymorphisms (SNPs) 
from VCF file in lollipop-style plot. Figure \@ref(fig:plotVCFdata) shows an 
example lollipop plot of real SNPs. Sample SNPs are a subset of 1000 variants 
and 50 samples from chromosome 22 taken from 1000 Genomes in VCF in the 
_VariantAnnotation_ package. 
Different colors depict the new SNP events in the circles. 
The number of circles indicates the number of SNP events. 

```{r plotVCFdata, fig.width=12,fig.height=5.5,dpi=72,fig.cap="lollipop plot for VCF data"}
library(VariantAnnotation) ## load package for reading vcf file
library(TxDb.Hsapiens.UCSC.hg19.knownGene) ## load package for gene model
library(org.Hs.eg.db) ## load package for gene name
library(rtracklayer)
fl <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
## set the track range
gr <- GRanges("22", IRanges(50968014, 50970514, names="TYMP"))
## read in vcf file
tab <- TabixFile(fl)
vcf <- readVcf(fl, "hg19", param=gr)
## get GRanges from VCF object 
mutation.frequency <- rowRanges(vcf)
## keep the metadata
mcols(mutation.frequency) <- 
    cbind(mcols(mutation.frequency), 
          VariantAnnotation::info(vcf))
## set colors
mutation.frequency$border <- "gray30"
mutation.frequency$color <-
    ifelse(grepl("^rs", names(mutation.frequency)), 
           "lightcyan", "lavender")
## plot Global Allele Frequency based on AC/AN
mutation.frequency$score <- round(mutation.frequency$AF*100)
## change the SNPs label rotation angle
mutation.frequency$label.parameter.rot <- 45
## keep sequence level style same
seqlevelsStyle(gr) <- seqlevelsStyle(mutation.frequency) <- "UCSC"
seqlevels(mutation.frequency) <- "chr22"
## extract transcripts in the range
trs <- geneModelFromTxdb(TxDb.Hsapiens.UCSC.hg19.knownGene, 
                         org.Hs.eg.db, gr=gr)
## subset the features to show the interested transcripts only
features <- c(range(trs[[1]]$dat), range(trs[[5]]$dat))
## define the feature labels
names(features) <- c(trs[[1]]$name, trs[[5]]$name)
## define the feature colors
features$fill <- c("lightblue", "mistyrose")
## define the feature heights
features$height <- c(.02, .04)
## set the legends
legends <- list(labels=c("known", "unkown"), 
                fill=c("lightcyan", "lavender"), 
                color=c("gray80", "gray80"))
## lollipop plot
lolliplot(mutation.frequency, 
          features, ranges=gr, type="circle", 
          legend=legends)
```

## Plot methylation data from bed format file

Any data can imported into a `GRanges` object can be viewed by _trackViewer_ package.
Sample methylations are random data generated for illustration and saved in bed format file.
The _rtracklayer_ package is used to import the methylation data into a `GRanges`.
The transcripts are extracted from `TxDb` object and assigned gene symbol with `org` database.
Here also show multiple transcripts could be shown in different colors and tracks.

```{r plotMethyBed, fig.width=12,fig.height=4,dpi=72,fig.cap="lollipop plot, pie layout"}
library(TxDb.Hsapiens.UCSC.hg19.knownGene) ## load package for gene model
library(org.Hs.eg.db) ## load package for gene name
library(rtracklayer)
## set the track range
gr <- GRanges("chr22", IRanges(50968014, 50970514, names="TYMP"))
## extract transcripts in the range
trs <- geneModelFromTxdb(TxDb.Hsapiens.UCSC.hg19.knownGene, 
                         org.Hs.eg.db, gr=gr)
## subset the features to show the interested transcripts only
features <- GRangesList(trs[[1]]$dat, trs[[5]]$dat, trs[[6]]$dat)
flen <- elementNROWS(features)
features <- unlist(features)
## define the feature track layers
features$featureLayerID <- rep(1:2, c(sum(flen[-3]), flen[3]))
## define the feature labels
names(features) <- features$symbol
## define the feature colors
features$fill <- rep(c("lightblue", "mistyrose", "mistyrose"), flen)
## define the feature heights
features$height <- ifelse(features$feature=="CDS", .04, .02)
## import methylation data from a bed file
methy <- import(system.file("extdata", "methy.bed", package="trackViewer"), "BED")
## subset the data to simplify information
methy <- methy[methy$score > 20]
## for pie plot, there are must be at least two numeric columns
methy$score2 <- max(methy$score) - methy$score
## set the legends
legends <- list(labels=c("methylated", "unmethylated"), 
                fill=c("white", "lightblue"), 
                color=c("black", "black"))
## lollipop plot, pie layout
lolliplot(methy, features, 
          ranges=gr, type="pie", 
          legend=legends)
```

## Plot lollipop plot for multiple patients in "pie.stack" layout

The percentage of methylation rates are shown by pie graph in different layers 
for different patients. 

```{r plotMethypieStack, fig.width=12,fig.height=4,dpi=72,fig.cap="lollipop plot, pie.stack layout"}
## simulate multiple patients
rand.id <- sample.int(length(methy), 3*length(methy), replace=TRUE)
rand.id <- sort(rand.id)
methy.mul.patient <- methy[rand.id]
## pie.stack require metadata "stack.factor", and the metadata can not be 
## stack.factor.order or stack.factor.first
len.max <- max(table(rand.id))
stack.factors <- paste0("patient", 
                        formatC(1:len.max, 
                                width=nchar(as.character(len.max)), 
                                flag="0"))
methy.mul.patient$stack.factor <- 
    unlist(lapply(table(rand.id), sample, x=stack.factors))
methy.mul.patient$score <- 
    sample.int(100, length(methy.mul.patient), replace=TRUE)
## for a pie plot, two or more numeric meta-columns are required.
methy.mul.patient$score2 <- 100 - methy.mul.patient$score
## set different color set for different patient
patient.color.set <- as.list(as.data.frame(rbind(rainbow(length(stack.factors)), 
                                                 "#FFFFFFFF"), 
                                           stringsAsFactors=FALSE))
names(patient.color.set) <- stack.factors
methy.mul.patient$color <- 
    patient.color.set[methy.mul.patient$stack.factor]
## set the legends
legends <- list(labels=stack.factors, col="gray80", 
                fill=sapply(patient.color.set, `[`, 1))
## lollipop plot
lolliplot(methy.mul.patient, 
          features, ranges=gr, 
          type="pie.stack", 
          legend=legends)
```

## Plot lollipop plot in caterpillar layout to compare two samples

The caterpillar layout can be used to side by side comparing two samples or
to display dense data.

```{r plotCaterpillar, fig.width=12,fig.height=6,dpi=72,fig.cap="lollipop plot, caterpillar layout"}
## use SNPsideID to set the layer of event
sample.gr$SNPsideID <- sample(c("top", "bottom"), 
                               length(sample.gr),
                               replace=TRUE)
lolliplot(sample.gr, features.gr)
```

## Dandelion plot hundreds SNPs

Sometimes, there are as many as hundreds of SNPs or methylation status involved in one gene.
Dandelion plot can be used to depict such dense SNPs or methylation. 
Please note that the height of the dandelion indicates the density of the events.

```{r dandelionPlot, fig.width=8,fig.height=4,dpi=72,fig.cap="dandelion plot"}
methy <- import(system.file("extdata", "methy.bed", package="trackViewer"), "BED")
length(methy)
## set the color of dandelion leaves.
methy$color <- 3
methy$border <- "gray"
## we suppose the total event are same (methy + unmethy)
## we rescale the methylation score by max value of the score 
m <- max(methy$score)
methy$score <- methy$score/m
# The area of the fan indicate the percentage of methylation or rate of mutation.
dandelion.plot(methy, features, ranges=gr, type="fan")
```